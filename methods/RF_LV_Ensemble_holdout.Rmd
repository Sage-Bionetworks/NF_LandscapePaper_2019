---
title: "RF_LatentVar_Ensemble_HoldOut"
author: "Jineta Banerjee"
date: '`r format(Sys.time(), "%d %B, %Y")`'
output: 
  html_document:
    toc: true
    number_sections: true
    toc_float:
      collapsed: false
      smooth_scroll: false
    fig_width: 7
    fig_height: 6
    fig_caption: true
    df_print: paged
    code_folding: hide
    
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r libraries, eval=TRUE, results='hide', message=FALSE, warning=FALSE, include=FALSE}

library(synapser)
library(synapserutils)
library(BiocManager)

library(tidyverse)
library(DT)
library(colorspace)
library(RColorBrewer)
library(wesanderson)

#Random Forest
library(randomForest)
library(e1071)
library(caret)
library(doParallel)


#plotting
library(AppliedPredictiveModeling)
transparentTheme(trans = .4)
library(pheatmap)
library(ggridges)

library(AnnotationDbi)
#library(hgu95av2.db)
#library(STRINGdb)
library(gridExtra)

#renv::init()
library(glue)

#Synapser
synLogin()
```


```{r make color palette}

## Make colors for plots
fabcolors = RColorBrewer::brewer.pal(n = 11,name = 'RdGy')
col1 = RColorBrewer::brewer.pal(n = 10,name = 'PRGn')
col2 = RColorBrewer::brewer.pal(n = 10,name = 'Spectral')
col3 = RColorBrewer::brewer.pal(n = 10,name = 'BrBG')
col4 = RColorBrewer::brewer.pal(n = 10,name = 'PiYG')
col5 = RColorBrewer::brewer.pal(n = 10,name = 'PuOr')
col6 = RColorBrewer::brewer.pal(n = 10,name = 'RdBu')


allcolors <- c(fabcolors, col1,col2,col3, col4, col5, col6)
allcolors <- list(allcolors)

morecolors1 <- wes_palette("Darjeeling1", n=4, type = "discrete")
morecolors1 <- list(morecolors1)

morecolors2 <- wes_palette("Moonrise2", n=3, type = "discrete")
morecolors2 <- list(morecolors2)

color_list <- c(allcolors, morecolors1, morecolors2)

```

## Introduction

This document describes training a random forest model using latent variables generated by [transfer learning approaches](https://www.cell.com/cell-systems/pdfExtended/S2405-4712(19)30119-X) as its input features. We are using the latent variables found in NF1 tumor data to train the forest to find the most important classifying LVs for the four tumor types in NF1. We chose to train a random forest classifier to identify NF tumortypes using the LVs for the following features of the model :

* robustness to high dimensionality data
* ability to handle unbalanced classes
* robustness to outliers and non-linear data
* quick training /prediction speeds
* low bias and moderate variance

Our goal is to find important latent variables that classify the various tumorTypes. We will then inspect the classifying features to find meaningful genesets that distinguish between two tumortypes.

Tumortypes represented in the data:

* Plexiform Neurofibroma
* MPNST
* Cutaneous Neurofibroma
* Neurofibroma

```{r download data from Synapse, eval=TRUE, results='hide', message=FALSE, warning=FALSE, include=FALSE}

#download data: LV by gene loadings
lv_entity <- synGet("syn18689545")
lv_all_pn <- readRDS(lv_entity$path)
gene_by_lv <- as.data.frame(lv_all_pn$Z)
recount_sample_by_lv <- as.data.frame(lv_all_pn$B)

# Load LVs of NF1 samples except the xenografts
lv_by_NF <- synTableQuery("SELECT * FROM syn21046991")$asDataFrame() %>%
  filter(tumorType!="NA",
         !grepl('xenograft', specimenID, ignore.case = T),
         !specimenID %in% c("BI386-004","CW225-001","DW356-002",
                            "JK368-003", "SK436-005"))

keep <- c("latent_var", "value", "specimenID")
lv_by_NF_select <- lv_by_NF[ ,keep] %>%
  group_by_at(vars(-value)) %>%  # group by everything other than the value column.
  mutate(row_id=1:n()) %>% ungroup() %>%  # build group index
  spread(key=latent_var, value=value) %>%    # spread
  dplyr::select(-row_id)   # drop the index 

specimen_tumortype <- unique(lv_by_NF[,c("specimenID", "tumorType")])

forest_data <- merge(lv_by_NF_select, specimen_tumortype, by = "specimenID")
rownames(forest_data) <- forest_data$specimenID
forest_data$tumorType <- as.factor(forest_data$tumorType)
forest_data <- forest_data[,2:ncol(forest_data)]

```

```{r}

## Load initial Fit
load(synGet("syn21317737")$path)

## Load Fit data (All the ensemble models described in this document are stored on Synapse)
load(synGet("syn21317654")$path)

```

## Partitioning the data into training and testing set:

We first partition the data into a holdout set and a model set. The model set (newforest) will be further partitioned into training set and test set by iterative random sampling that will be used to train and test the ensemble models during its iterations. The holdout set will be used to test the ensemble models at the very end. The holdout test set will be naive set that will not be seen by any of the models until the very end.

```{r make holdout set, eval=TRUE}

#Make the test and training datasets
set.seed(998)  #(if you want to keep the exact same training and testing dataset then uncomment this line)
inTraining <- createDataPartition(as.factor(forest_data$tumorType), p = .70, list = FALSE)

newforest <- forest_data[ inTraining,]
holdout  <- forest_data[-inTraining,]

```


### Initial model to find optimum mtry and ntree

The newforest dataset was split into 75% training and 25% testing dataset. The function _createDataPartition_ is used to create balanced splits of the data. Since the _tumorType_ argument to this function is a factor, the random sampling occurs within each class and should preserve the overall class distribution of the data.

```{r split the data for training, eval=TRUE}

#Make the test and training datasets
set.seed(998)  #(if you want to keep the exact same training and testing dataset then uncomment this line)
inTraining <- createDataPartition(as.factor(newforest$tumorType), p = .75, list = FALSE)

training <- forest_data[ inTraining,]
testing  <- forest_data[-inTraining,]

```

#### Model training and Crossvalidation :

We first trained an initial model on the training dataset using iterative _mtrys_ (1:100) and _ntrees_ (250, 500, 1000, 2000) trees. The model was crossvalidated using 5-fold crossvalidation technique. The details of the model are given below:


```{r create model and check fit, eval=TRUE, fig.height=8, fig.width=8}


# 10 fold validation control
fitControl <- trainControl(## 5-fold CV
                           method = "repeatedcv",
                           number = 5,
                           ## repeated ten times
                           repeats = 5)

n <- sqrt(ncol(forest_data))
tunegrid <- expand.grid(.mtry = c(1:100))

#Find the classes:
summary(training$tumorType)


## Construct the initial random forest model called Fit (the code is commented out to facilitate quick rendering of html file by loading the Fit from Synapse)

# #start parallelization
# cl <- makePSOCKcluster(10)
# registerDoParallel(cl)
# 
# set.seed(9998)
# Fit <- train(tumorType ~ .,
#              data = training[,c(1:ncol(training))],
#              method = "rf",
#              ntree= 1000,
#              tuneGrid = tunegrid,
#              proximity=TRUE,
#              importance = TRUE,
#              trControl = fitControl,
#              verbose = TRUE)
# 
# 
# ## When you are done:
# stopCluster(cl)

print(" Check the fit of the initial model")                 
Fit


# Select final number of ntrees
# accuracy <- vector()
# besttune <- vector()
# iter <- c(250, 500, 1000, 2000)
# accuracy[4] <- max(Fit$results$Accuracy)
# besttune[4] <- Fit$bestTune$mtry
# 
# ROC <- data.frame(iter=numeric(),
#                    accuracy=numeric())
# ROC <- as.data.frame(cbind(iter,accuracy, besttune))
# 
# # ROC curve:
# theme_update(text = element_text(size=15))
# ggplot(ROC,  aes(x=iter, y=accuracy)) +
#   geom_point(aes(size=1)) +
#   geom_line() +
#   coord_cartesian(ylim = c(0,1)) +
#   labs(main="The model", x="ntrees :: Number of trees in the forest", y= "Accuracy of the model") 

#Highest accuracy <- ntrees = 1000

#plot the model
theme_update(text = element_text(size=15))
ggplot(Fit$results,  aes(x=mtry, y=Accuracy)) +
  geom_point(aes(size=1)) +
  geom_line() +
  coord_cartesian(ylim = c(0,1)) +
  labs(main="The model", x="mtry :: Number of features for each split", y= "Accuracy of the model") 

print("Check the clustering of the samples according to the model")
MDSplot(Fit$finalModel, 
        as.factor(training$tumorType), 
        k=2, palette=NULL, 
        pch=as.numeric(training$tumorType), 
        cex=1, 
        cex.axis= 1.1,
        cex.lab = 1.1,
        cex.main = 1.1,
        main= "MDS Plot of the initial training set")
legend("topright",
       inset=0.01, 
       cex= 1.1,
       legend=levels(training$tumorType), 
       fill=brewer.pal(6, "Set1"))

#Order errors using OOB
#head(Fit$finalModel$err.rate[order(Fit$finalModel$err.rate[,1]),])

```


```{r predict model, eval=TRUE}

#Use model to predict labels of test data
pred <- predict(Fit, newdata = testing[,c(1:length(colnames(testing)))])

#store predicted labels in the test dataframe
testing$pred <- pred

```


```{r model accuracy, eval=TRUE, fig.height=10, fig.width=10}

# Check the accuracy of the model
library(DT)

conf_matrix <- confusionMatrix(data = testing$pred, 
                              reference = as.factor(testing$tumorType), 
                              mode = "prec_recall")

## Make a performance histogram from initial iterations of the forest

perf <- as.data.frame(conf_matrix$byClass)
perf$Class <- rownames(perf)
perf <- perf %>%
  dplyr::select(Class, F1)

# estimate variable importance
importance <- varImp(Fit, scale=TRUE)

# Select top important features
list_init <- as.data.frame(importance$importance)


varImpPlot(Fit$finalModel,
           main = "Important variables in the forest",
           n.var = 80,
           type = 2)


# DT:: datatable(list_init)

#conf_matrix$table

```



### Iterating over models

We tried an ensemble approach where we ran 500 randomized iterations of our forest with the optimum mtrys we found from our initial model. In each iteration, a new randomly sampled training set and testing set was generated (without replacement) to train and test 500 independent models. We then plotted the performance of all the 500 independent models to get a distribution of F1 scores for each class. A higher median F1 score for a class overall would mean a higher classification accuracy for that class.

```{r Make a model iteratively, fig.width=8, fig.height=8, message=FALSE, warning=FALSE}


# FeatureList <- list()
# perf_new <- perf

# Load the Featurelist and perf list stored on synapse
#load(synGet("syn21267354")$path)

#The model building code has been commented out below for quick rendering of html

# for (i in 1:500){
#   # make new train-test set
#   inTraining <- createDataPartition(as.factor(newforest$tumorType), p = .75, list = FALSE)
#   training <- forest_data[ inTraining,]
#   testing  <- forest_data[-inTraining,]
#   
#   tunegrid <- expand.grid(.mtry = 51)
# 
#   #start parallelization
#   cl <- makePSOCKcluster(10)
#   registerDoParallel(cl)
#   
#   #make new model
#   Fit_new <- train(tumorType ~ .,
#              data = training[,c(1:ncol(training))],
#              method = "rf",
#              ntree= 1000,
#              #mtry = 51,            #using mtry=51 as seen as best tune for initial Fit
#              tuneGrid = tunegrid,
#              #classwt =
#              proximity=TRUE,
#              importance = TRUE,
#              trControl = fitControl,
#              verbose = TRUE)
#   
#   # When you are done:
#   stopCluster(cl)
# 
#   # predict test set with the model to get F1 scores
#   pred <- predict(Fit_new, newdata = testing[,c(1:length(colnames(testing)))])
#   #store predicted labels in the test dataframe
#   testing$pred <- pred
# 
#   #Make confusion matrix
#   conf_matrix <- confusionMatrix(data = testing$pred,
#                               reference = as.factor(testing$tumorType),
#                               mode = "prec_recall")
# 
#   ## Store F1 scores from various iterations of the forest
#   df <- as.data.frame(conf_matrix$byClass)
#   perf_new[, glue('Iter{i}')] <- df$F1
#   #perf[, Class] <- rownames(df)
# 
# 
#   #Store Feature importance for all iterations in a list
#   # estimate variable importance
#   importance <- varImp(Fit_new, scale=TRUE)
# 
#   # Select top important features
#   features <- as.data.frame(importance$importance)
# 
#   FeatureList[[i]] <- (features)
# }


# Plot histogram of all F1 scores
#Make long df
perf_new$Class <- as.factor(perf_new$Class)
perf_new_long <- gather(perf_new, iteration, All_scores, F1:Iter500, factor_key=TRUE)

par(mfrow=c(2,1)) 

theme_update(legend.text = element_text(size=8), 
      axis.text.x  = element_text(size=10),
      axis.text.y = element_text(size=10),
      text = element_text(size=10))

ggplot(perf_new_long, aes(x=All_scores, fill=Class, color= Class)) + 
  geom_histogram( binwidth=0.05, alpha=0.5, position="dodge") +
  theme(legend.position="top") +
  scale_color_brewer(palette="Spectral")+
  scale_fill_brewer(palette="Spectral") +
  labs(title="Histogram of raw F1 scores for iterations of RF",x="F1 scores from different iterations of RF", y = "Number of RF iterations with a given F1 score") +
  xlim(0, 1)

ggplot(perf_new_long, aes(x=All_scores, fill=Class, color=Class)) + 
  #geom_histogram( binwidth=0.05, alpha=0.5, position="dodge") +
  geom_density(alpha=0.5) +
  theme(legend.position="top") +
  #scale_color_manual(values=allcolors[[1]][12:18])
  scale_color_brewer(palette="Spectral")+
  scale_fill_brewer(palette="Spectral") +
  labs(title="Density plot of F1 scores for iterations of RF",x="F1 scores from different iterations of RF", y = "Proportions of RF iterations with a given F1 score") +
  xlim (0,1)

# print("The median F1 scores for first ensemble")
# table(rowMedians(as.matrix(perf_new[,c(2:ncol(perf_new))])))

```


#### Top 40 important variables for the first ensemble model

Lets take a look at the important latent variables picked up by our models as top classifiers for the different classes.

```{r features, eval=T, fig.width=10, fig.height=10}


# Filter Importance scores of features for each Class
features_cNF <- as.data.frame(sapply(FeatureList, `[[`, 1))
features_MPNST <- as.data.frame(sapply(FeatureList, `[[`, 2))
features_NF <- as.data.frame(sapply(FeatureList, `[[`, 3))
features_pNF <- as.data.frame(sapply(FeatureList, `[[`, 4))

# # Plot the drop of importance in features in cNF
# data <- features_cNF[order(-features_cNF$V1),]
# data$id <- rownames(data)
# data <- data %>% mutate(index = row_number())
# data <- data[,c("V1","id", "index")]
# ggplot(data = data,
#        aes(x=index, y=V1)) +
#   geom_point()

## From this plot the importance seems to stagnate


# Plot the distribution of importance scores of features
ridgeplot_classes <- function(featurelist, dataframe, class){
  #Take row median
  dataframe$median <- rowMedians(as.matrix(dataframe[,]))
  #add Class column
  dataframe$Celltype <- rownames(FeatureList[[1]])
  #Take top50 rows
  dataframe <- dataframe[order(-dataframe$median),]
  new_df <- dataframe[(1:40),]
  #make long df
  dataframe_long <- gather(new_df, iteration, All_scores, V1:V500, factor_key=TRUE)
  
  #save the ordered df
  var_name <- glue('ordered_{class}') # Construct the name
  assign(var_name, new_df, env=.GlobalEnv)
 
  #make ridgeplot
  theme_update(legend.text = element_text(size=8), 
      axis.text.x  = element_text(size=15),
      axis.text.y = element_text(size=10),
      text = element_text(size=15))
  ggplot(dataframe_long, aes(x=All_scores, y=Celltype, fill=Celltype)) + 
  geom_density_ridges(scale = 3, rel_min_height = 0.01, alpha= 0.5)  +
  theme(legend.position="none") +
  scale_color_manual(values=color_list[[1]]) +
  labs(title= glue('{class}: Top 40 Features'),x="Importance Score", y = "Proportion of RFs") +
  xlim(-10,100)
  
}

ridgeplot_classes(FeatureList, features_cNF, "Cutaneous Neurofibroma")
ridgeplot_classes(FeatureList, features_MPNST, "MPNST")
ridgeplot_classes(FeatureList, features_NF, "Neurofibroma")
ridgeplot_classes(FeatureList, features_pNF, "Plexiform Neurofibroma")
```


### Testing sufficiency of top features as predictors of classes

Since the mean decrease in Gini index flattens out after the top 40 features, we selected the top 40 features from all the classes and took their union to train a second ensemble of random forests. 

```{r}

# Take all top features for all classes
`ordered_Cutaneous Neurofibroma`$Celltype <- gsub("`", "", `ordered_Cutaneous Neurofibroma`$Celltype)
ordered_MPNST$Celltype <- gsub("`", "", ordered_MPNST$Celltype)
ordered_Neurofibroma$Celltype <- gsub("`", "", ordered_Neurofibroma$Celltype)
`ordered_Plexiform Neurofibroma`$Celltype <- gsub("`", "", `ordered_Plexiform Neurofibroma`$Celltype)

allfeatures <- unique(c(`ordered_Cutaneous Neurofibroma`$Celltype, ordered_MPNST$Celltype, ordered_Neurofibroma$Celltype, `ordered_Plexiform Neurofibroma`$Celltype))
allfeatures <- gsub("`", "", allfeatures)

commonfeatures1 <- intersect(`ordered_Cutaneous Neurofibroma`$Celltype, ordered_MPNST$Celltype)
commonfeatures2 <- intersect(ordered_Neurofibroma$Celltype, `ordered_Plexiform Neurofibroma`$Celltype)
commonfeatures <- intersect(commonfeatures1,commonfeatures2)


full_feature_list <- c(`ordered_Cutaneous Neurofibroma`$Celltype, ordered_MPNST$Celltype, ordered_Neurofibroma$Celltype, `ordered_Plexiform Neurofibroma`$Celltype)
full_feature_list <- gsub("`", "", full_feature_list)


```

To build the ensemble of forests, only selected features were provided as input to the models, the data was randomly sampled at each iteration of model building to generate a new training set at each iteration, and the initial holdout set (that was never used in any of the previous model building iterations) was used as the test set to evaluate performace of each of the 500 models. 

```{r random forest with top features, fig.width=8, fig.height=8, message=FALSE, warning=FALSE}

# FeatureList_final <- list()
# perf_final <- perf

## Restrict features from train and test set
keep <- colnames(newforest) %in% allfeatures
final_model_data <- newforest[,keep]
final_model_data$tumorType <- newforest$tumorType

keep <- colnames(holdout) %in% allfeatures
final_holdout <- holdout[,keep]
final_holdout$tumorType <- holdout$tumorType

#The model building code has been commented out below for quick rendering of html

 # for (i in 1:500){
 #  # make new train-test set
 #  inTraining <- createDataPartition(as.factor(final_model_data$tumorType), p = .75, list = FALSE)
 #  training <- final_model_data[ inTraining,]
 #  testing  <- final_holdout #final_model_data[-inTraining,]  #use the holdout test data that none of the potential models have seen before
 # 
 #  #start parallelization
 #  cl <- makePSOCKcluster(10)
 #  registerDoParallel(cl)
 # 
 #  #make new model
 #  Fit_new <- train(tumorType ~ .,
 #             data = training[,c(1:ncol(training))],
 #             method = "rf",
 #             ntree= 1000,
 #             #mtry = 45,
 #             tuneGrid = tunegrid,
 #             #classwt =
 #             proximity=TRUE,
 #             importance = TRUE,
 #             trControl = fitControl,
 #             verbose = TRUE)
 # 
 #  # When you are done:
 #  stopCluster(cl)
 # 
 #  # predict test set with the model to get F1 scores
 #  pred <- predict(Fit_new, newdata = testing[,c(1:length(colnames(testing)))])
 #  #store predicted labels in the test dataframe
 #  testing$pred <- pred
 # 
 #  #Make confusion matrix
 #  conf_matrix <- confusionMatrix(data = testing$pred,
 #                              reference = as.factor(testing$tumorType),
 #                              mode = "prec_recall")
 # 
 #  ## Store F1 scores from various iterations of the forest
 #  df <- as.data.frame(conf_matrix$byClass)
 #  perf_final[, glue('Iter{i}')] <- df$F1
 #  #perf[, Class] <- rownames(df)
 # 
 # 
 #  #Store Feature importance for all iterations in a list
 #  # estimate variable importance
 #  importance <- varImp(Fit_new, scale=TRUE)
 # 
 #  # Select top important features
 #  features <- as.data.frame(importance$importance)
 # 
 #  FeatureList_final[[i]] <- (features)
 # }

df <- perf_final

# Plot histogram of all F1 scores
#Make long df
perf_final_long <- gather(perf_final, iteration, All_scores, 3:ncol(perf_final), factor_key=TRUE)

par(mfrow=c(2,1)) 

theme_update(legend.text = element_text(size=8), 
      axis.text.x  = element_text(size=10),
      axis.text.y = element_text(size=10),
      text = element_text(size=10))

ggplot(perf_final_long, aes(x=All_scores, fill=Class, color=Class)) + 
  #geom_histogram( binwidth=0.05, alpha=0.5, position="dodge") +
  geom_density(alpha=0.5) +
  theme(legend.position="top") +
  #scale_color_manual(values=allcolors[[1]][12:18])
  scale_color_brewer(palette="Spectral")+
  scale_fill_brewer(palette="Spectral") +
  labs(title="Density plot of F1 scores for iterations of RF",x="F1 scores from different iterations of RF", y = "Proportions of RF iterations with a given F1 score") +
  xlim (0,1)


```

We found that the new ensemble of 500 forests fared better with the restricted feature-set with most of the classes showing an improvement in their median F1 scores. This suggested to us that the top 40 features from each class were sufficient for efficient classification of the tumortypes. 

```{r top features from 2nd iteration, fig.width=10, fig.height=10, message=FALSE, warning=FALSE}

# Filter Importance scores of features for each Class
final_cNF <- as.data.frame(sapply(FeatureList_final, `[[`, 1))
final_MPNST <- as.data.frame(sapply(FeatureList_final, `[[`, 2))
final_NF <- as.data.frame(sapply(FeatureList_final, `[[`, 3))
final_pNF <- as.data.frame(sapply(FeatureList_final, `[[`, 4))


#Calculate median scores for each
# Plot the distribution of importance scores of features
ridgeplot_classes <- function(featurelist, dataframe, class){
  #Take row median
  dataframe$median <- rowMedians(as.matrix(dataframe[,]))
  #add Class column
  dataframe$Celltype <- rownames(featurelist[[1]])
  #Take top50 rows
  dataframe <- dataframe[order(-dataframe$median),]
  new_df <- dataframe[(1:10),]
  #make long df
  dataframe_long <- gather(new_df, iteration, All_scores, V1:V500, factor_key=TRUE)
  
  #save the ordered df
  var_name <- glue('ordered_{class}') # Construct the name
  assign(var_name, new_df, env=.GlobalEnv)
 
  #make ridgeplot
  theme_update(legend.text = element_text(size=8), 
      axis.text.x  = element_text(size=15),
      axis.text.y = element_text(size=10),
      text = element_text(size=15))
  ggplot(dataframe_long, aes(x=All_scores, y=Celltype, fill=Celltype)) + 
  geom_density_ridges(scale = 3, rel_min_height = 0.01, alpha= 0.5)  +
  theme(legend.position="none") +
  scale_color_manual(values=color_list[[1]]) +
  labs(title= glue('{class}: Top 40 Features'),x="Importance Score", y = "Proportion of RFs") +
  xlim(-10,100)
  
}

ridgeplot_classes(FeatureList_final, final_cNF, "final_Cutaneous Neurofibroma")
ridgeplot_classes(FeatureList_final, final_MPNST, "final_MPNST")
ridgeplot_classes(FeatureList_final, final_NF, "final_Neurofibroma")
ridgeplot_classes(FeatureList_final, final_pNF, "final_Plexiform Neurofibroma")


```


## Plot the gene loadings the top 5 important LVs for each of the tumortypes

So we selected this restricted feature set for our later downstream analyses. The plots below show the gene loadings of the top important LVs.

### Cutaneous Neurofibroma

```{r Plot cNF loadings, eval=T, fig.width=8, fig.height=8}


## Plot the genes in the top LVs

plotGenes <- function(plot_data, list){
  
  ## Transform list to enable plotting
list$LV <- list$Celltype
list$LV <- gsub("`", "", list$LV)
##Function to extract numbers from data in columns
library(stringr)
numextract <- function(string){
  str_extract(string, "\\-*\\d+\\.*\\d*")
}
list$LatentVar <- numextract(list$LV)
list$LatentVar <- glue('V{list$LatentVar}')
  
  for (i in (unique(list$LatentVar)[1:10])) {
 
  tidy <- plot_data %>%
    dplyr::select(i) %>% 
    tibble::rownames_to_column('genes')
  
  p <- ggplot(tidy %>% top_n(30, get(i))) +
    aes(x=reorder(genes, -get(i)), y=get(i)) +
    geom_bar(stat="identity") +
    theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5)) +
    ylim(c(0,8)) +
    xlab("Genes") +
    ylab("Loadings") +
    ggtitle(glue('Gene Loadings for interesting LV: {i}'))
  
  print(p)
  
  }

}

plotGenes(gene_by_lv, `ordered_final_Cutaneous Neurofibroma`)


```

### Neurofibroma

```{r Plot NF loadings, eval=T, fig.width=8, fig.height=8}

## Plot the genes in the top LVs

plotGenes(gene_by_lv, ordered_final_Neurofibroma)

```

### Plexiform Neurofibroma

```{r Plot pNF loadings, eval=T, fig.width=8, fig.height=8}

## Plot the genes in the top LVs

plotGenes(gene_by_lv, `ordered_final_Plexiform Neurofibroma`)


```

### MPNST

```{r plot MPNST loadings, eval=T, fig.width=8, fig.height=8}

## Plot the genes in the top LVs

plotGenes(gene_by_lv, ordered_final_MPNST)

```

```{r save imp datafiles, eval=F, fig.width=10, fig.height=10}

#save(FeatureList, perf_new, file = "RF_LV_Ensemble.Rdata")
```

```{r sessionInfo, eval=T}

sessionInfo()

```
